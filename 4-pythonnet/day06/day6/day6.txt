前情回顾

1. fork()创建进程注意事项
2. 进程相关函数：
   
   os.getpid()  获取当前进程PID
   os.getppid() 获取父进程的PID 
   os._exit() 退出进程
   sys.exit() 

3. 孤儿进程和僵尸进程
   
   * 如何避免僵尸进程？
     1. wait  waitpid回收子进程
     2. 创建二级子进程
     3. 使用signal处理子进程退出行为

4. 聊天室程序  

   确定需求--》整体设计（确定技术点，模块，结构）--》功能分析--》代码实现--》基本测试  

**************************************************************

一. multiprocessing 模块创建进程

   1. 进程创建流程
     【1】 将需要子进程执行的事件封装为函数
     【2】 通过模块的Process类创建进程对象，关联函数
     【3】 可以通过进程对象设置进程信息及属性
     【4】 通过进程对象调用start启动进程
     【5】 通过进程对象调用join 回收进程
   
   2. 函数接口使用
      
     【1】 Process()
     	   功能：创建进程对象
	   参数：target 绑定的目标函数
	   	 args  元组 给target绑定函数按位置传参
		 kwargs 字典  给target函数关键字传参

     【2】 p.start()
           功能:启动新的进程

	   * 此时进程才真正产生，会将target绑定函数作为进程执行内容
  
     【3】 p.join([timeout])
           功能：阻塞等待回收子进程
	   参数：超时时间


      注意：* 使用Process创建子进程同样是复制父进程的空间代码		段，父子进程运行互不影响

            * 子进程只运行target绑定函数，其余均由父进程执行

	    * join如果不回收子进程，子进程可能成为僵尸进程

	    * multiprocessing模块创建的子进程不能使用标准输入

            * 通常使用Process创建进程，父进程只负责进程创建和回收，子进程负责具体事件执行


    3. 进程对象属性

       p.name  进程名称
       
       p.pid   进程PID号

       p.is_alive()  查看进程是否在生命周期

       p.daemon  设置父子进程的退出关系
          * 如果daemon设置为True则子进程会随父进程退出
	  * 必须在start前设置该属性
	  * daemon=True一般不会和join()一同使用


    4. 自定义进程类

      【1】 作用 ： 当进程功能比较复杂，无法通过一个函数简单实现，又希望将整体功能进行封装。此时可以设计进程类完成

      【2】 编写流程

          * 定义进程类继承Process
	  * 编写__init__方法用于添加属性，使用super加载父类__init__,获取父类自动提供的方法
	  * 重写Process中的run方法作为进程类启动函数
       
      【3】 使用方法
          
	  * 使用自定义类实例化对象
	  * 通过实例对象调用start() 方法创建进程，此时会自动加载运行类中的run()
	  * 实例对象调用join() 回收子进程


二. 进程池技术

  1. 必要性
     
    【1】进程的创建和销毁过程消耗的计算机资源较多
    【2】当任务量众多，每个任务在很短时间内完成，需要频繁的创建和销毁，此时对计算机的压力较大
    【3】进程池技术很好的解决了上述问题
  
  2. 原理： 创建一定数量的进程来处理事件，事件处理完毕进程不退出，而是继续处理其他事件。直到所有待处理事件全部处理完毕统一销毁进程。增加进程重复利用，降低资源消耗。

  3. 进程池实现

    【1】 创建进程池对象，放入适当的进程
        
	from multiprocessing import  Pool

	Pool(processes)
	功能: 创建进程池对象
	参数：指定进程数量，默认会根据系统自动判断

     【2】 将事件加入进程池执行队列
         
	 pool.apply_async(func,args,kwds)
	 功能：使用进程池执行func函数
	 参数：func 事件函数
	       args 元组 给func按照位置传参
	       kwds 字典 给func按照键值传参
	 返回值 ： 事件函数对象  obj.get() 获取func返回值


	 pool.apply(func,args,kwds)
	 功能：使用进程池同步执行func函数
	 参数：func 事件函数
	       args 元组 给func按照位置传参
	       kwds 字典 给func按照键值传参

	 pool.map(func,iter)
	 功能 ： 将要做的事件加入进程池
	 参数：func 事件函数
	       iter 迭代对象
	 返回值 ： 得到函数返回值列表

	     
     【3】 关闭进程池
         
	 pool.close()
	 功能： 关闭进程池

     【4】 回收进程池
     
	 pool.join()
	 功能：回收进程池中的进程


三. 进程间通信（IPC）

   1. 必要性： 进程空间独立，资源不能共享，此时在需要进程间数据传输时就需要特定的手段进行数据通信。

   2. 进程间通信方法 ：管道，消息队列，共享内存，信号，信号量，套接字。


   
   3. 管道通信（Pipe）

     【1】通信原理：在内存中开辟管道空间，生成管道操作对象，多个进程使用同一管道对象进行读写操作即可实现通信

     【2】实现方法

       from multiprocessing import Pipe 

       fd1,fd2 = Pipe(duplex = True)
       功能 ： 创建管道
       参数 ： 默认表示双向管道，如果为False表示单向管道
       返回值 ： 表示管道的两端读写对象，如果是双向管道则都		  可以读写操作，单向管道则fd1只读，fd2只写

       fd.recv()
       功能： 从管道读取内容
       返回值：返回获取的数据

       fd.send(data)
       功能：向管道写入内容
       参数：要写入的数据

    4. 消息队列 

      【1】 通信原理 ： 在内存中建立队列模型，进程通过队列将消息存入，或者从队列中取出，完成进程间通信

      【2】 实现方法 

        from multiprocessing import Queue

	q = Queue(maxsize=0)
	功能 ： 创建队列对象
	参数 ： 最多存放的消息个数
	返回值：队列对象

	q.put(data,[block,timeout])
	功能： 向队列存入消息
	参数:  data 存入内容
	       block = False 表示非阻塞
	       timeout 为超时时间
	
	q.get([block,timeout])
	功能: 从队列取出消息
	参数：block = False 设置非阻塞
	      timeout 超时时间
	返回值：取出的内容

	q.full()  判断队列是否为满
	q.empty() 判断队列是否为空
	q.qsize() 获取队列中消息数量
	q.close() 关闭队列


作业 ： 1. multiprocessing完成：创建两个子进程，同时分别复制		  一个文件的上下两部分，各自将复制内容写入到一个新的		  文件中

        2. 整理聊天室代码思路
	3. 复习mysql 基本语句





