回顾:
1.http响应
    响应格式:响应行:HTTP/1.1  200  OK
    　　　　 响应头:描述响应信息
    　　　　 空行
    　　　　 响应体:响应的具体内容
    http server:*接受浏览器的HTTP请求
                *查看请求内容
                *将一个网页内容返回给客户端
2.IO分类
    【1】阻塞IO:默认的IO行为,效率低
    【2】非阻塞IO:设置非阻塞行为,超时检测
        setblocking()
        settimeout()
    【3】IO多路复用
        select(rlist,wlist,xlist,[timeout])
3.位运算:& | ^ << >>
*********************************************
一.基于poll方法的IO多路复用
1.　p = select.poll()
    功能:创建poll对象
    返回值:poll对象
2.　p.register(fd,event)
    功能:注册关注的IO事件
    参数:fd 要关注的IO
    　　 event 要关注的IO事件类型
        *常用类型:POLLIN  读IO事件(rlist)
         　　　　 POLLOUT 写IO事件(wlist)
         　　　　 POLLERR 异常IO　(xlist)
         　　　　 POLLHUP 断开连接
        *e.g. p.register(sockfd,POLLIN|POLLERR)
    p.unregister(fd)
    功能:取消对IO的关注
    参数:IO对象或者IO对象的fileno
3.  events = p.poll()
    功能:阻塞等待监控的IO事件发生
    返回值:返回就绪的IO
          events格式[(fileno,event),(),...]
          每个元组为一个就绪IO,
          元组第一项是该IO的fileno,
          第二项为该IO就绪的事件类型
    *需要通过fileno寻找　对应的IO对象,建立对应字典确保
     字典中的IO和关注的IO时刻保持一致
     字典格式:{fileno:io_obj}
4.  poll_server步骤
    【1】创建套接字
    【2】将套接字register
    【3】创建查找字典,并维护
    【4】循环监控IO发生
    【5】处理发生的IO
二.基于epoll的IO多路复用

    1. 使用方法 ：基本与poll相同
      * 将对象生成 改为 epoll
      * 将所有事件类型改为EPOLL类型  
    2. 特点
      * epoll 效率比select和poll要高
      * epoll 能够同时监控IO的数量比select poll要多
      * epoll 的触发方式比poll要多 （EPOLLET边缘触发）

三.struct模块的使用
   1.原理:将一组简单的数据进行打包，转换为bytes格式。
         或者将一组bytes格式数据解包为python的数据类型。
   2. 接口使用
    【1】 st = Struct(fmt)
	    功能:生成结构化对象
	    参数:fmt　定制的数据结构
	    e.g. 数据结构:1　b'zhangsan'　1.75
	         fmt:'i8sf'
    【2】 st.pack(value,...)
        功能:将一组数据按照指定格式转换为bytes
    	参数:要转换的一组数据
	    返回值:bytes字节串
    【3】 st.unpack(bytes_data)
        功能:将bytes字节串按照指定格式解析
	    参数:要解析的字节串
	    返回值:解析后的数据
    【4】 struct.pack(fmt,value,...)
        struct.unpack(fmt,bytes_data)
	    说明： 通过struct模块直接调用pack，unpack需要加第一个参数为fmt。其他用法相同。

四.本地套接字
    1.功能：用于本地两个程序之间进行数据收发
    2.套接字文件：用于本地套接字通信时，进行数据传输的介质
    3.本地套接字通信流程
        【1】 创建本地套接字
          sockfd = socket(AF_UNIX,SOCK_STREAM) 
        【2】 绑定本地套接字文件
          sockfd.bind(file)
        【3】 监听，接收连接，收发消息
          listen() -->accept()-->recv/send()
cookie： linux文件类型
         b(块设备文件)   
         c(字符设备文件)     
         d(目录) 
         - (普通文件)
         l(链接文件)     
         s(套接字文件)        
         p（管道文件）
cookie: 
         判断文件是否存在： os.path.exists(file)
         删除文件 ： os.remove(file)

五.多任务编程
   1.意义：充分利用计算机多核资源，同时运行多个任务，提高程序执行效率。
   2.实现方案：多进程，多线程
   3.并行：多个任务利用计算机多核资源在同时执行，多个任		   
     　　　 务间为并行关系
     并发：多个任务都被接受，但是内核在任务间不断切换，		
      　　　达到了好像多个任务都被处理的效果，实际每一时刻		
      　　　只有一个任务占用内核
六.进程（process）
   1.定义：程序在计算机中的一次执行过程
      * 程序是一个可执行文件，是静态的，占有磁盘空间
      * 进程是一个动态执行过程，占有计算机运行资源，有一定的生命周期。
   2.如何产生一个进程
    【1】用户空间通过调用程序或者特定接口发起进程创建
    【2】操作系统接受用户请求，开始创建进程
    【3】操作系统调配计算机资源，确定进程状态等
    【4】操作系统将创建的进程提供给用户使用
   3.进程概念
    【1】cpu时间片：如果一个进程占有cpu内核，则称这个进程占有cpu时间片。
    【2】PCB（进程控制块）：在内存中开辟一块空间，用于存放进程的基本信息，
    　　 也用于系统对进程的识别。
    【3】进程ID（PID）：系统为每个进程分配一个大于0的整数，作为ID。
     　　所有进程ID不会重复。
        Linux命令查看PID： ps  -aux
    【4】父子进程：系统中每一个进程（除了初始进程）都有唯一的父进程，
    　　 可以有0个或多个子进程。父子进程便于系统对进程的管理。  
	 　　查看进程数：pstree
	　　 查看父子进程PID：ps  -ajx
    【5】进程状态
        三态 
	   就绪态 ：进程具备执行条件，等待分配cpu资源
	   运行态 ：进程占有cpu时间片，正在运行
	   等待态 ：进程暂停执行，让出cpu
	   五态 （增加新建和终止）
	   新建态：创建进程获取资源的过程
	   终止态：进程结束，释放资源的过程
	   
       STAT列标志    
	  * 第一个字母表示进程状态
	   S  等待态
	   D  等待态
	   T  等待态
	   R  运行态
	   Z  僵尸
	  * 后面的标志表示进程特征
	   < 优先级较高
	   N 优先级较低
	   + 前台进程
	   s 会话组长
	   l 有多线程
      3. 进程运行特征

      【1】 进程可以使用计算机多核资源
	【2】 进程是计算机分配资源的最小单位
	【3】 进程之间运行互不影响，各自独立
	【4】 每个进程空间独立，各有使用各自空间内容


面试要求： 1. 什么是进程，进程有什么特点
	   2. 进程有哪些状态，状态之间如何转换



七. 基于fork的多进程编程

   import  os

   pid = os.fork()
   功能 : 创建新的进程
   返回值： 整数，如果创建进程失败返回一个负数，如果成功则		 
   原有进程返回新进程的PID号，新进程得到0



