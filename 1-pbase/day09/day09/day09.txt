day08 回顾:
  两个容器:
    集合set 和 固定集合 frozenset
      可变        不可变
  集合的创建:
    构造函数:
       set()
       set(range(10)))
    字面值:
       {1, 2, 3, 4}
    集合推导式:
       {x ** 2 for x in range(1, 10)}
  固定集合的创建:
    构造函数:
       frozenset()
       frozenset(range(10))
  集合的运算:
    &交集   |并集   ^对称补集  
    -补集   <子集   >超集    ==相等  !=不等 
    <=子集或相等   >= 超集或相等
    in / not in 

  集合的方法:
    S.add(x)      增加
    S.remove(x)   删除
    S.discard(x)  删除(但不提示错误)
    S.clear()
    S.pop()       删除随机元素
    S.copy()

  能用容器类的函数
    len(x) min(x) max(x) .....
  
函数 function
  函数是面向过程编程的最小单位

两条语句:
  def 语句
    语法:
      def 函数名(形参变量1, 形参变量2, ....):
          语句块
    作用:
       创建函数, 用函数名绑定这个函数

  调用表达式:
    函数名(实参1, 实参2, ....)

  return 语句
    作用:
      结束当前函数的执行,返回到调用此函数的地方
    格式:
      return [表达式]
    


day09 笔记:
python函数的参数传递(把数据给函数)
  传递方式:
    位置传参
      序列传参
    关键字传参
      字典关键字传参

位置传参:
  实际参数(实参)的对应关系与形式参数(形参)的对应关系是按位置
    来依次对应的
  示意:
    def mymin(a, b, c):
        pass

    mymin(    1, 2, 3)
        
  说明:
    实际参数和形式参数通过位置进行传递和匹配
    实际参数的个数必须与形式参数的个数相同
  示例见:
    positional_give_args.py

    
序列传参
  序列传参是指在函数调用过程中,用*将序列拆解后按位置进行传递的
    传参方式

  示例见:
    sequence_give_args.py
  说明:
    序列传参时,序列拆解的位置将与形参一一对应

关键字传参:
  关键字传参是指传参时,按着形参的名称给形参赋值
  实参和形参按名称进行匹配

  示例见:
    keywords_give_args.py
  说明:
    实参和形参接形参名进行匹配,可以不按位置进行匹配

字典关键字传参:
  是指实参为字典,将字典用**拆解后进行关键字传参的传参方式

  示例见:
    dict_keyword_give_args.py
  说明:
    字典的键名和形参名必须一致
    字典的键名必须为符合标识符命名规则的字符串
    字典的键名要在形参中存在
  
练习:
  已知有列表:
    L = [1, 2, True, None, 3.14]
    调用print函数,打印用'#'号分隔的文字信息到终端上
  print(....)  # 打印  1#2#True#None#3.14


函数的综合传参:
  1. 函数的传参方式,在能确定形参能唯一匹配到相应实参的情况
    下可以任意组合
  2. 函数的位置传参要先于关键字传参

  示例:
    def myfun1(a, b, c):
        pass
    myfun1(100, c=300, b=200)  # 正确
    myfun1(c=300,b=200, 100)   # 错的
    myfun1(100, *[200, 300])   # 正确
    myfun1(*[100, 200], 300)   # 正确
    myfun1(100, *[200], 300)   # 正确
    myfun1(100, **{'c':300, 'b':200})  # 正确
    myfun1(**{'c':300, 'b':200}, a=100)  # 正确



可变 和不可变类型的容器作为实参传递的区别:
  可变类型的实参作为参数传递时,在函数内部可以改变容器内的数据

  示例见:
    list_as_args.py
    list_as_args2.py



----- 以下讲函数的定义(创建函数的def语句的形参列表)----
函数的缺省参数:
  语法:
    def 函数名(形参名1=默认实参1, 形参名2=默认实参2, ...):
        语句块
  示例见:
    default_args.py

  说明:
    缺省参数必须自右至左依次存在,如果一个参数有缺省参数,则其
    右侧的所有参数都必须有缺省参数,如:
        def test_fn(a, b=10, c):  是错的
    缺省参数可以有0个,1个或多个,甚至全部都有缺省参数
  示例:
    def fn(a, b=10, c):  # 错误
        pass
    def fn(a=0, b=10, c=20):  # 这是对的
        pass

练习:
  写一个函数myadd,此函数可以计算两个数,三个数及四个数的和
    def myadd(...):
        ...
    
    print(myadd(10, 20))  # 30
    print(myadd(100, 200, 300))  # 600
    print(myadd(1, 2, 3, 4))  # 10




函数形参的定义方式:
  1. 位置形参
  2. 星号元组形参
  3. 命名关键字形参
  4. 双星号字典形参

位置形参 
  语法:
    def 函数名(形参名1, 形参名2, ...):
        语句块

星号元组形参:
  语法:
    def 函数名(*元组形参名):
        语句块
  作用:
    收集多余的位置传参
  说明:
    在一个函数定义中元组形参名最多只能有一个,一般命名为'args'
  示例见:
    star_tuple_args.py

练习:
  写一个函数 mysum 可以传入任意个数字实参,返回所有实参的和
    def mysum(*args):
        ...
    
    print(mysum(1, 2, 3, 4))  # 10
    print(mysum(1, 3, 5, 7, 9))  # 25


命名关键字形参
  语法:
    def 函数名(*, 命名关键字形参1, 命名关键字形参2, ...):
        语句块
    或
    def 函数名(*args, 命名关键字形参1, 命名关键字形参2, ..):
        语句块
  作用:
    强制所有的参数都必须用关键字传参或字典关键了传参
  示例见:
    named_keyword_args.py
    named_keyword_args2.py
  
双星号字典形参
  语法:
    def 函数名(**字典形参名):
        语句块
  作用:
    收集多余的关键字传参
  说明:
    字典形参名一般命名为'kwargs'
    一个函数内字典形参最多只能有一个
  示例见:
    star_dict_args.py

函数的参数说明:
  位置形参,缺省参数,星号元组形参,双星号字典形参可以混合使用

函数参数自左至右的顺序为:
  1. 位置形参
  2. 星号元组形参
  3. 命名关键字形参
  4. 双星号字典形参

  示例:
    def fn(a, b=20, *args, c=30, d=40, **kwargs):
        pass
    fn(1)
    fn(100, 200, 300, 400, c='C', d='D', e='E')
  
练习:
  已知内建函数max帮助文档为:
    max(...)
        max(iterable) -> value
        max(arg1, arg2, *args) -> value
  仿造 max写一个mymax函数,功能与max完全相同
    (要求不允许调用max)
  测试程序如下:
     print(mymax([6, 8, 3, 5]))  # 8
     print(mymax(100, 200))      # 200
     print(mymax(1, 3, 5, 9, 7)) # 9




全局变量 和 局部变量
  局部变量 local varible:
    定义在函数内部的变量称为局部变量(函数的形参也是局部变量)
    局部变量只能在函数内部使用
    局部变量在函数调用时才能够被创建,在函数调用之后会自动销毁
    当有同名的全局变量和局部变量时,优先访问局部变量
  全局变量 global variable:
    定义在函数外部,模块内部的变量称为全局变量
    全局变量,所有函数都可以直接访问(但函数内不能将其直接赋值)

局部变量说明:
  在函数内部赋值语句不会对全局变量造成影响
  局部变量只能在其被声明的函数内部访问,而全局变量可以在整数模
  块范围内访问
示例见:
  global_local.py

globals 和 locals 函数:
  globals()  返回当前全局作用域内变量的字典
  locals()   返回当前局部作用域内变量的字典

  示例见:
    globals_and_locals.py


练习:
  1. 算出 100 ~ 999 以内的水仙花数(Narcissistic number)
    水仙花数是指百位的3次方加上十位的3次方加上个位的3次方
    等于原数的整数
    例如:  153 = 1**3 + 5**3 + 3**3
    答案:  153, 370, ...
  2. 完全数: 
     1 + 2 + 3 = 6 (6为完全数)
     1, 2, 3都为6的因数(能被一个数x整除的数为y,则y为x的因数)
     1 x 6 = 6
     2 x 3 = 6
     完全数是指除自身以外的所有因数之和相加等于自身的数
      求4~5个完全数,并打印
     答案:
       6
       28
       496
       ...
  3. 写一个myrange()函数,参数可以传1~3个,实际意义同range函数
    规则相同,此函数返回符合range(...) 函数规则的列表
    如:
      L = myrange(4)
      print(L)  # [0, 1, 2, 3]
      L = myrange(4, 6)
      print(L)  # [4, 5]
      L = myrange(1, 10, 3)
      print(L)  # [1, 4, 7]




