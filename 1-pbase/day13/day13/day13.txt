day12回顾:
函数装饰器
  作用:
    在不改变函数的定义及函数调有和的情况下为函数或类
    添加功能或修改功能
  语法:
    def 装饰器函数名(fn被装饰函数):
        创建闭包函数
        def fx(...):
             ...
        return 闭包函数

    @装饰器函数名
    def 被装饰函数名(形参列表):
        语句块
  函数的文档字符串:
    def fa():
        '''这是文档字符串'''
    fa.__doc__
    help(fa)  # 查看文档字符串

  函数的 __name__ 属性
    绑定函数的名称
       def 函数名():
           pass
  语法:
    [装饰器1]
    [装饰器2]
    [...]
    def 函数名(位置形参, *args, 命名关键字形参, **kwargs):
        ....

模块 Module
   包含有数据,函数，类等组成的程序组

   math.pi      # 数据
   math.sin(0)  # 函数

模块的导入语句(import 语句)
  三种：
    import 模块名 [as 模块新名], 模块名2, ...
    from 模块名 import 属性名 [as 属性新名], 属性名2....
    from 模块名 import *

数学模块 math
时间模块 time
系统模块 sys

模块的种类:
   1. 内建模块
   2. 标准库模块
   3. 第三方模块
   4. 自定义模块




day13 笔记
自定义模块
  要求:
    1. 模块文件后缀名必须以.py结尾
    2. 模块文件名必须是合法的标识符
    3. 避免名称和内建模块名冲突
  导入方式:
    import 语句
    from import 语句
    from import * 语句
  示例见:
    mymod.py
    test_mymod.py  



import 语句搜索模块的路径顺序:
  1. 搜索内建模块
  2. 搜索程序运行时的路径(当前工作目录)
  3. 搜索sys.path提供的路径
     sys.path是一个列表,里面放的都是模块的索引路径

模块化编程的优点:
  1. 有利于多人合作开发
  2. 使代码更加易于维护
  3. 提高代码的复用率(模块可以被其它代码或者模块使用)
  4. 模块化编程有助于解决变量名冲突(重名)问题,模块内的全局变量的
    作用域为模块内全局
  
模块的加载过程
  在模块被导入时,模块的所有语句会执行
  如果一个模块已经被导入,则再次导入时不会重新执行模块内的语句

模块的重新加载
    import mymod
    import imp
    imp.reload(mymod)  # 重新加载mymod模块 


模块被导入和执行的过程:
  1. 先搜索相关路径找模块(.py)
  2. 判断是否有此模块对应的.pyc文件,如果.pyc文件比.py文件新
     则直接加载.pyc文件 
  3. 否则用模块.py 文件生成.pyc文件并加载执行

模块的编译 compile
                编译               解释执行
  mymod.py    -------> mymod.pyc --------> python3



模块的文档字符串
  模块内第一个没有赋值给任何变量的字符串是文档字符串

  模块的__doc__属性 
    用于绑定模块的文档字符串

  模块的 __file__属性 
    __file__ 用于绑定模块文件的路径名
    注:
      内建模块没有__file__属性
  
  模块的 __name__ 属性
    __name__属性用来记录模块自身的名字 
    
    作用:
      1. 记录模块名 
      2. 用来判断是否为主模块 
    说明:
      1. 当此模块作为主模块(也就是第一个运行的模块)运行
         时,__name__ 绑定 '__main__'
      2. 当此模块不是主模块,而是被其它模块导入时,__name__绑
         定模块名

    
      
模块的 __all__ 列表
  模块中的__all__列表是一个用来存放可导入属性的字符串列表

  作用:
    当用from xxx import *导入时,只导入 __all__列表内的属性 

  示例见:
    mymod2.py


模块的隐藏属性:
  模块中以下划线(_)开头的属性,在from xxx import * 导入时
  将不被导入, 通常称这些属性为隐藏属性

  作用:
    限制from import *语句,不导入隐藏属性

  示例见:
    mymod3.py



随机模块 random
  作用:
    用于模拟随机输出
  文档参见:
    python_base_docs_html/随机模块random.py
  

练习:
  1. 猜数字游戏:
    随机生成一个0~100之间的整数,用变量x绑定
    让用户循环输入一个整数,用变量y绑定,输出猜数字的结果
       如果y等于x,则提示'恭喜您猜对了',并结束猜数字
       如果y大于x,则提示:'您猜大了'
       如果y小于x,则提示:'您猜小了'

    直到猜对为止,显示用户猜数字的次数后退出程序



包(模块包) package
  包的定义
    包是将模块以文件夹的组织形式进行分组管理的方法

  作用:
    将一系列模块进行分类管理,有利于访问命名冲突
    可以在需要时加载一个或部分模块,而不是全部模块

  包示例:
    mypack/
        __init__.py
        menu.py
        games/
            __init__.py
            contra.py
            supermario.py
            tanks.py
        office/
            __init__.py
            word.py
            excel.py

包的导入:
  同模块的导入规则:
    import 包名 [as 包别名]
    import 包名.模块名 [as 模块新名]
    import 包名.子包名.模块名 [as 模块新名]
    ...

    from 包名 import 模块名 [as 模块新名]
    from 包名.子包名 import 模块名 [as 模块新名]
    from 包名.子包名.模块名 import 属性名 [as 属性新名]
    ...

    from 包名 import *
    from 包名.模块名 import *
    ...
  
import 语句 搜索包的路径顺序
  1. 搜索程序运行时的路径(当前工作路径)
  2. sys.path提供的路径

包的 __init__.py 文件 
  __init__.py 是常规包内必须存在的文件
  __init__.py 会在包加载时被自动调用

  作用:
    编写此包的内容
    在内部填写包的文档字符串
  示例见:
    mypack/__init__.py
  

__init__.py 内的 __all__ 列表
  作用:
    用来记录此包中有哪儿些子包或模块需要导入
    当用 from 包 import * 语句导入模块时,只查找__all__中
      所有的模块或子包
  说明:
    __all__ 列表只在from xxx import * 起作用
  示例见:
    mypack/games/__init__.py 


包的相对导入
  包的相对导入是指包内模块的相互导入

  语法:
    from 相对路径包或模块 import 属性或模块名
    或
    from 相对路径包或模块 import *
  相对路径:
    在from import 语句和from import *语句中可以使用相对导入
    在 from 和 import 间可以用相对路径
    . 代表当前目录(文件夹)
    .. 代表上一级目录
    ... 代表上二级目录
    .... 以此类拟
    注: 相对导入时不能超出包的外部
  示例见:
    mypack.games/contra.py 里的gameover函数


  



练习:
  1. 随机生成6位密码:
      可以作为密码的字符有:
        a-z, A-Z, 0-9
    随机生成一个6位的密码

  2. 模拟斗地主发牌，牌共54张
    种类:
      黑桃('\u2660'), 梅花('\u2663'), 方块('\u2665'),
      红桃('\u2666')
    数字:
       A2-10JQK
    王牌: 大小王
    三个人，每人发17张牌，底牌留三张
    输入回车，打印第1个人的17张牌
    输入回车，打印第2个人的17张牌
    输入回车，打印第3个人的17张牌
    输入回车，打印3张底牌

  3. 将学生信息管理程序拆分为模块
    要求:
       1. 主事件循环放在main.py中
       2. show_menu函数放在menu.py中
       3. 写学生操作相关的函数放在student_info.py中


















 



